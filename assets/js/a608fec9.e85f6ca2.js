"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[868],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=l(n),f=r,h=m["".concat(c,".").concat(f)]||m[f]||u[f]||a;return n?o.createElement(h,i(i({ref:t},p),{},{components:n})):o.createElement(h,i({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3145:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var o=n(5773),r=(n(7294),n(3905));const a={title:"Icon",sidebar_position:5},i=void 0,s={unversionedId:"components/icon",id:"components/icon",title:"Icon",description:"In most projects, there is a library of icons that's used across all parts of the app. Usually (with exceptions for course) the library consists of monochrome square icons. That means that the icons always have 1:1 aspect ratio, the same viewbox size and etc. Creating all those icons one by one is very verbose.",source:"@site/docs/components/icon.md",sourceDirName:"components",slug:"/components/icon",permalink:"/e-prim/components/icon",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Icon",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Grid",permalink:"/e-prim/components/grid"},next:{title:"Theme Utils",permalink:"/e-prim/theme-utils"}},c={},l=[{value:"API",id:"api",level:2}],p={toc:l};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In most projects, there is a library of icons that's used across all parts of the app. Usually (with exceptions for course) the library consists of monochrome square icons. That means that the icons always have 1:1 aspect ratio, the same viewbox size and etc. Creating all those icons one by one is very verbose."),(0,r.kt)("p",null,"To solve that, the Icon component serves as a basic wrapper for your SVGs, while you only focus on their content."),(0,r.kt)("p",null,"An example of your specific icon component would look like this. If your SVG consists of multiple elements in the root, you can use react fragment to wrap them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'export const ArrowIcon: FC<IconProps> = (props) => (\n  <BaseIcon {...props}>\n    <path\n      d="M4 12H20M20 12L12 4M20 12L12 20"\n      stroke="currentColor"\n      strokeLinecap="round"\n      strokeLinejoin="round"\n    />\n  </BaseIcon>\n);\n')),(0,r.kt)("p",null,"When creating an icon, it's important to pay attention at 2 important things:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"All colors need to be passed as ",(0,r.kt)("inlineCode",{parentName:"li"},"currentColor"),". This ensures that your icon will inherit the colors from it's parent (by using the ",(0,r.kt)("inlineCode",{parentName:"li"},"color")," prop of the icon)"),(0,r.kt)("li",{parentName:"ol"},"The configured SVG is assumed to be 24px. It's easier if you can maintain your library in a single size. If that's not an option, the BaseIcon component accepts a property ",(0,r.kt)("inlineCode",{parentName:"li"},"viewBoxSize")," which instructs it what's the original size of your SVG")),(0,r.kt)("p",null,"And it's usage would look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'<ArrowIcon color="neutral.0" size={32} />\n')),(0,r.kt)("h2",{id:"api"},"API"),(0,r.kt)("p",null,"Apart from all SVG props as well as all box props, the icon API exposes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * This is the size of the icon that you wish to render in a specific scenario.\n * If not provided, it defaults to the configured default of 24\n */\nsize?: number;\n")))}u.isMDXComponent=!0}}]);