"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[603],{3905:(e,t,o)=>{o.d(t,{Zo:()=>c,kt:()=>d});var n=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(o),d=r,m=u["".concat(s,".").concat(d)]||u[d]||h[d]||a;return o?n.createElement(m,i(i({ref:t},c),{},{components:o})):n.createElement(m,i({ref:t},c))}));function d(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=o.length,i=new Array(a);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<a;p++)i[p]=o[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}u.displayName="MDXCreateElement"},4224:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var n=o(5773),r=(o(7294),o(3905));const a={title:"Box",sidebar_position:1},i=void 0,l={unversionedId:"components/box",id:"components/box",title:"Box",description:"The box component is the base of all. It's the most basic component and it should preferably used as a base for every component in your library. It lies on the concept of the as prop, where you tell the Box what HTML element to render. Based on that prop, not only the DOM changes, but you will get a full auto-complete of the properties of that specific HTML element that you've selected (thanks react-polymorphic-box for the inspiration). The default HTML element if none is specified is a plain div.",source:"@site/docs/components/box.md",sourceDirName:"components",slug:"/components/box",permalink:"/e-prim/components/box",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Box",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Configuration",permalink:"/e-prim/configuration"},next:{title:"Typography",permalink:"/e-prim/components/typography"}},s={},p=[{value:"ResponsiveValue",id:"responsivevalue",level:3},{value:"API",id:"api",level:2}],c={toc:p};function h(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The box component is the base of all. It's the most basic component and it should preferably used as a base for every component in your library. It lies on the concept of the ",(0,r.kt)("inlineCode",{parentName:"p"},"as")," prop, where you tell the Box what HTML element to render. Based on that prop, not only the DOM changes, but you will get a full auto-complete of the properties of that specific HTML element that you've selected (thanks ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kripod/react-polymorphic-box"},"react-polymorphic-box")," for the inspiration). The default HTML element if none is specified is a plain ",(0,r.kt)("inlineCode",{parentName:"p"},"div"),"."),(0,r.kt)("p",null,"The box also exposes all system properties for your usage, so you can style it easily. Here is a brief of what it looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'/**\n * regular div with:\n * - padding on all sides equal to 4px\n * - margin on all sides equal to 8px for small devices and 16px for big devices\n */\n<Box p={1} m={{ xs: 2, md: 4 }} width="100%">\n  ...content\n</Box>\n\n<Box as="button" onClick={console.log}>\n  My Button\n</Box>\n\n// specifying an a element will automatically allow you to add href property\n<Box as="a" href="https://dstoyanoff.github.io/e-prim>\n  e-prim\n</Box>\n')),(0,r.kt)("h3",{id:"responsivevalue"},"ResponsiveValue"),(0,r.kt)("p",null,"As shown in the above example, most of the values can either take the form a simple value or a responsive value. The type for that looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export type ResponsiveValue<T> = T | Partial<Record<keyof TBreakpoint, T>>;\n")),(0,r.kt)("p",null,"When a property is defined a responsive one, you choose whether to just specify the value in it's type or provide an object that contains a breakpoint value as a key and the exact value of the property to use for that breakpoint. This saves you from manually writing media queries, which greatly reduces the code."),(0,r.kt)("h2",{id:"api"},"API"),(0,r.kt)("p",null,"The full box API is described below."),(0,r.kt)("p",null,"As a base, the box inherits ",(0,r.kt)("inlineCode",{parentName:"p"},"ComponentProps<E>"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," extends React's ",(0,r.kt)("inlineCode",{parentName:"p"},"ElementType"),". This gives us all HTML properties, which we won't describe here, but only the added ones. The CSSObject type is the one exported from ",(0,r.kt)("inlineCode",{parentName:"p"},"@emotion/react")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'/**\n * Specify the HTML element to render to the DOM.\n * The ElementType comes from React itself and lists all possible tags\n */\nas?: ElementType;\n\n/**\n * Background and color accept a color key. The color key is a dot notation of the structure you\'ve defined in your theme.\n * With the example theme that we\'ve defined, it would look like "primary.normal" or "neutral.2".\n * Internally, this will resolve the value from your theme and put it in the CSS\n */\n\nbackground?: PaletteKey;\ncolor?: PaletteKey;\n\n/**\n * The borders have the same logic as the colors, with the addition of a boolean variant of the prop.\n * If passed as boolean, this would use the defaultBorder that you\'ve defined in the theme.\n * All border props use the width defined in the theme (or 1px if not provided).\n * If you need a variable width, you should use the regular CSS props approach\n */\n\nborder?: PaletteKey | boolean;\nborderTop?: PaletteKey | boolean;\nborderRight?: PaletteKey | boolean;\nborderBottom?: PaletteKey | boolean;\nborderLeft?: PaletteKey | boolean;\n\n/**\n * Specifies a radius key from the config to use for that element\n */\nradius?: ResponsiveValue<TRadius>;\n\n/**\n * Similarly to the radius, it applies the selected z-index from the theme\n */\nzIndex?: keyof TZIndex;\n\n/**\n * The typography key has a similar structure to colors.\n * It\'s a dot notation key from what you defined in the theme.\n * It would automatically apply all typography styles for the given variant.\n * This is useful if you want to have text inside a div, without adding another DOM child.\n * Most of the times, this won\'t be needed as the Typography component can be used instead.\n */\ntypography?: TypographyKey;\n\n/**\n * The following properties are just raw CSS properties exposed as component props for convenience.\n * Their value is not modified in any form, except for responsiveness, where defined\n */\n\nposition?: ResponsiveValue<CSSObject["position"]>;\noverflow?: CSSObject["overflow"];\nminWidth?: ResponsiveValue<CSSObject["minWidth"]>;\nwidth?: ResponsiveValue<CSSObject["width"]>;\nmaxWidth?: ResponsiveValue<CSSObject["maxWidth"]>;\nminHeight?: ResponsiveValue<CSSObject["minHeight"]>;\nheight?: ResponsiveValue<CSSObject["height"]>;\nmaxHeight?: ResponsiveValue<CSSObject["maxHeight"]>;\ngrow?: ResponsiveValue<CSSObject["flexGrow"]>;\n\n// cursor: pointer and userSelect: none are automatically applied for elements with onClick handler provided, so you don\'t have to pass it for clickable elements\ncursor?: CSSObject["cursor"];\n')))}h.isMDXComponent=!0}}]);